<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Jet Engine Designer — Sliders + Thrust + Slow-mo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --panel-w: 340px; }
  html, body { margin:0; height:100%; background:#000; color:#fff; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  canvas { display:block; width:100vw; height:100vh; }

  #panel {
    position: fixed; top: 10px; left: 10px; width: var(--panel-w);
    background: rgba(0,0,0,0.75); border: 1px solid #333;
    border-radius: 12px; padding: 10px;
    z-index: 10; backdrop-filter: blur(4px);
    max-height: 90vh; overflow-y: auto;
  }
  #toggle {
    position: fixed; top: 10px; left: calc(var(--panel-w) + 20px);
    background:#0b0b0b; border:1px solid #333; color:#fff;
    border-radius:8px; padding:6px 10px; cursor:pointer; z-index:11;
  }

  .row { display:grid; grid-template-columns: 150px 1fr auto; gap:8px; align-items:center; margin:6px 0; }
  input[type="range"] { width: 100%; }
  .row output { min-width: 48px; text-align:right; font-size:12px; }
  .tooltip { cursor:help; color:#0ff; margin-left:4px; }
  details { border:1px solid #333; border-radius:10px; padding:8px; margin-top:8px; }
  details summary { cursor:pointer; outline:none; }
  .stage { border:1px solid #333; border-radius:8px; padding:6px; margin:6px 0; }
  .btn {
    background:#151515; border:1px solid #444; color:#fff;
    border-radius:8px; padding:4px 8px; cursor:pointer; font-size:12px;
  }
  .btn:hover { background:#262626; }
  .bar { display:flex; gap:6px; flex-wrap:wrap; }
  .pill { border:1px solid #444; border-radius:999px; padding:2px 8px; font-size:11px; color:#ccc; }
  hr { border:0; border-top:1px solid #222; margin:8px 0; }
  .note { color:#aaa; font-size:11px; line-height:1.25; }

  .row .mini { display:flex; gap:6px; align-items:center; }
</style>
</head>
<body>

<button id="toggle">Hide UI</button>

<div id="panel">
  <h1>Engine Designer <span class="pill">γ=1.4</span> <span class="pill">R=287</span> <span class="pill">cp=1004</span></h1>

  <details open>
    <summary><b>Environment & Inlet</b></summary>
    <div class="row">
      <label>Ambient T [K] <span class="tooltip" title="How warm the outside air is. Warmer = softer air.">❔</span></label>
      <input id="Ta" type="range" min="200" max="330" step="1" value="288" oninput="this.nextElementSibling.value=this.value">
      <output>288</output>
    </div>
    <div class="row">
      <label>Ambient P [kPa] <span class="tooltip" title="How heavy the air is. Higher = thicker air.">❔</span></label>
      <input id="Pa" type="range" min="40" max="110" step="0.1" value="101.3" oninput="this.nextElementSibling.value=this.value">
      <output>101.3</output>
    </div>
    <div class="row">
      <label>Freestream Mach <span class="tooltip" title="How fast the plane is going. 0 = still, 2 = really fast.">❔</span></label>
      <input id="M0" type="range" min="0" max="2.0" step="0.01" value="0.25" oninput="this.nextElementSibling.value=this.value">
      <output>0.25</output>
    </div>
    <div class="row">
      <label>Capture area A₀ [m²] <span class="tooltip" title="How wide the engine mouth is. Big = more air.">❔</span></label>
      <input id="A0" type="range" min="0.05" max="5.00" step="0.01" value="0.30" oninput="this.nextElementSibling.value=this.value">
      <output>0.30</output>
    </div>
    <div class="row">
      <label>Duct height scale <span class="tooltip" title="How tall the duct looks on the screen.">❔</span></label>
      <input id="Hscale" type="range" min="0.05" max="0.9" step="0.01" value="0.40" oninput="this.nextElementSibling.value=this.value">
      <output>0.40</output>
    </div>
    <div class="row">
      <label class="mini">Play speed<span class="tooltip" title="Slow-mo lets you watch air travel through stages.">❔</span></label>
      <div class="mini">
        <button class="btn" id="btnSlow">Slow-mo</button>
        <button class="btn" id="btnNormal">Normal</button>
      </div>
      <output id="timeScaleOut">1.00×</output>
    </div>
  </details>

  <details open>
    <summary><b>Stages & Geometry</b></summary>
    <div class="bar">
      <button class="btn" onclick="addStage('compressor')">+ Compressor</button>
      <button class="btn" onclick="addStage('combustor')">+ Combustor</button>
      <button class="btn" onclick="addStage('turbine')">+ Turbine</button>
      <button class="btn" onclick="addStage('nozzle')">+ Nozzle</button>
      <button class="btn" onclick="resetDefault()">Reset default</button>
    </div>
    <div id="stageList"></div>
  </details>

  <details open>
    <summary><b>Advanced</b></summary>
    <div class="row">
      <label>Mech η (shaft) <span class="tooltip" title="How good the gears are. 1 = perfect.">❔</span></label>
      <input id="etaMech" type="range" min="0.5" max="1" step="0.01" value="0.99" oninput="this.nextElementSibling.value=this.value">
      <output>0.99</output>
    </div>
    <div class="row">
      <label>Streamlines <span class="tooltip" title="How many lines of air you see.">❔</span></label>
      <input id="nLines" type="range" min="6" max="40" step="1" value="18" oninput="this.nextElementSibling.value=this.value">
      <output>18</output>
    </div>
    <div class="row">
      <label>Line density <span class="tooltip" title="How many dots on each line.">❔</span></label>
      <input id="nPackets" type="range" min="20" max="200" step="1" value="70" oninput="this.nextElementSibling.value=this.value">
      <output>70</output>
    </div>
    <div class="row">
      <label>Trail length [px] <span class="tooltip" title="How long each dot leaves a trail.">❔</span></label>
      <input id="trail" type="range" min="6" max="60" step="1" value="18" oninput="this.nextElementSibling.value=this.value">
      <output>18</output>
    </div>
  </details>

  <details open>
    <summary><b>Thrust Calculator</b></summary>
    <div class="row">
      <label>Altitude [m] <span class="tooltip" title="How high the airplane is.">❔</span></label>
      <input id="alt_m" type="range" min="0" max="12000" step="100" value="0" oninput="this.nextElementSibling.value=this.value">
      <output>0</output>
    </div>
    <div class="row">
      <label>Air speed [m/s] <span class="tooltip" title="How fast the plane moves through air.">❔</span></label>
      <input id="V0_ms" type="range" min="0" max="600" step="5" value="0" oninput="this.nextElementSibling.value=this.value">
      <output>0</output>
    </div>
    <div class="row">
      <label>Final thrust [N]</label>
      <output id="thrustN">0</output>
      <button id="btnThrust" class="btn">Compute</button>
    </div>
  </details>

  <hr>
  <div class="note">• Panel scrolls if tall. • Dashes animate; reseed when speed changes. • ❔ tooltips are kid-simple.</div>
</div>

<canvas id="cv"></canvas>


/* =========================  Utilities & Constants  ========================= */
<script>
const gamma = 1.4, R = 287, cp = 1004; // [-], [J/(kg·K)], [J/(kg·K)]
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d', { alpha:false });
let W=0, H=0, DPR=1;
let dashPhase = 0;
let timeScale = 1.0;

function resize(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  cv.width=Math.floor(innerWidth*DPR);
  cv.height=Math.floor(innerHeight*DPR);
  cv.style.width='100vw';
  cv.style.height='100vh';
  ctx.setTransform(DPR,0,0,DPR,0,0);
  W=innerWidth; H=innerHeight;
}
addEventListener('resize', resize); resize();

/* =========================  UI / Stage Management  ========================= */
const el = id => document.getElementById(id);
let stages = [];

function addStage(type){
  const id = Math.floor(Math.random()*1e9);
  const base = { id, type, L:0.20, Aout:1.00 };
  if(type==='compressor') Object.assign(base,{PR:4.0, eta:0.86});
  if(type==='combustor') Object.assign(base,{dPpct:5.0, TtOut:1500, Aout:1.05});
  if(type==='turbine') Object.assign(base,{eta:0.90, Aout:1.10});
  if(type==='nozzle') Object.assign(base,{throat:0.55, exit:0.35, L:0.22});
  stages.push(base);
  rebuildList();
}
function removeStage(id){ stages = stages.filter(s=>s.id!==id); rebuildList(); }

function rebuildList(){
  const host=el('stageList'); host.innerHTML='';
  stages.forEach(s=>{
    const d=document.createElement('div'); d.className='stage';
    const html=[];
    html.push(`<div class="bar" style="justify-content:space-between;align-items:center;"><b>${s.type}</b><span><button class="btn" onclick="removeStage(${s.id})">remove</button></span></div>`);
    html.push(`<div class="row"><label>Length L/Lₑ [-]</label><input type="number" step="0.01" value="${s.L}" onchange="upd(${s.id},'L',this.value)"><output></output></div>`);
    if(s.type!=='nozzle'){
      html.push(`<div class="row"><label>Area Aᵒ/Aᶦ [-]</label><input type="number" step="0.01" value="${s.Aout}" onchange="upd(${s.id},'Aout',this.value)"><output></output></div>`);
    }
    if(s.type==='compressor'){
      html.push(`<div class="row"><label>PR (Pₜout/Pₜin) [-]</label><input type="number" step="0.1" value="${s.PR}" onchange="upd(${s.id},'PR',this.value)"><output></output></div>`);
      html.push(`<div class="row"><label>ηᶜ (isentropic) [-]</label><input type="number" step="0.01" value="${s.eta}" onchange="upd(${s.id},'eta',this.value)"><output></output></div>`);
    }
    if(s.type==='combustor'){
      html.push(`<div class="row"><label>ΔPₜ [% drop]</label><input type="number" step="0.1" value="${s.dPpct}" onchange="upd(${s.id},'dPpct',this.value)"><output></output></div>`);
      html.push(`<div class="row"><label>Tₜ,out [K]</label><input type="number" step="1" value="${s.TtOut}" onchange="upd(${s.id},'TtOut',this.value)"><output></output></div>`);
    }
    if(s.type==='turbine'){
      html.push(`<div class="row"><label>ηᵗ (isentropic) [-]</label><input type="number" step="0.01" value="${s.eta}" onchange="upd(${s.id},'eta',this.value)"><output></output></div>`);
    }
    if(s.type==='nozzle'){
      html.push(`<div class="row"><label>Throat Aᵗ/Aᶦ [-]</label><input type="number" step="0.01" value="${s.throat}" onchange="upd(${s.id},'throat',this.value)"><output></output></div>`);
      html.push(`<div class="row"><label>Exit Aᵉ/Aᶦ [-]</label><input type="number" step="0.01" value="${s.exit}" onchange="upd(${s.id},'exit',this.value)"><output></output></div>`);
    }
    d.innerHTML=html.join('');
    host.appendChild(d);
  });
}
function upd(id,key,val){ const s=stages.find(x=>x.id===id); s[key]=parseFloat(val); }

/* sensible default engine */
function resetDefault(){
  stages=[];
  addStage('compressor'); stages[0].PR=8.0; stages[0].L=0.22; stages[0].Aout=0.80;
  addStage('combustor');  stages[1].dPpct=5; stages[1].TtOut=1500; stages[1].L=0.18; stages[1].Aout=1.15;
  addStage('turbine');    stages[2].eta=0.90; stages[2].L=0.20; stages[2].Aout=1.10;
  addStage('nozzle');     stages[3].throat=0.55; stages[3].exit=0.30; stages[3].L=0.22;
  rebuildList();
}
resetDefault();

/* toggle panel */
const toggleBtn=document.getElementById('toggle'); const panel=document.getElementById('panel');
let panelHidden=false;
toggleBtn.onclick=()=>{ panelHidden=!panelHidden; panel.style.display=panelHidden?'none':'block'; toggleBtn.textContent=panelHidden?'Show UI':'Hide UI'; };

/* =========================  Thermo helpers  ========================= */
const smooth = t=>t*t*(3-2*t);
function aFromT(T){ return Math.sqrt(gamma*R*T); }
function T_static(Tt,M){ return Tt/(1+0.5*(gamma-1)*M*M); }
function P_static(Pt,M){ return Pt/Math.pow(1+0.5*(gamma-1)*M*M, gamma/(gamma-1)); }
function massFlux(M,Pt,Tt){
  const phi=Math.pow(1+0.5*(gamma-1)*M*M, -(gamma+1)/(2*(gamma-1)));
  return (Pt/Math.sqrt(Tt))*Math.sqrt(gamma/R)*M*phi; // kg/(s·m²)
}
function critMassFlux(Pt,Tt){
  const term=(gamma+1)/2;
  const phi=Math.pow(term, -(gamma+1)/(2*(gamma-1)));
  return (Pt/Math.sqrt(Tt))*Math.sqrt(gamma/R)*phi;
}
function solveM_subsonic(G,Pt,Tt){
  const Gmax=critMassFlux(Pt,Tt);
  if(G>=Gmax) return 1.0; // choked
  let lo=1e-6,hi=0.999,mid=0.5;
  for(let i=0;i<40;i++){
    mid=0.5*(lo+hi);
    const f=massFlux(mid,Pt,Tt);
    if(f>G) hi=mid; else lo=mid;
  }
  return mid;
}

/* =========================  Geometry / Field  ========================= */
const xPadL=0.08, xPadR=0.08, xLeft=xPadL, xRight=1-xPadR; let stagesXSpans=[];

function buildField(){
  const Ta=+el('Ta').value;
  const Pa_kPa=+el('Pa').value; const Pa=Pa_kPa*1000;
  const M0=+el('M0').value;
  const A0=Math.max(0.001, +el('A0').value);
  const etaMech=Math.max(0.5, Math.min(1.0, +el('etaMech').value));

  const T0=Ta, a0=aFromT(T0), V0=M0*a0;
  const Pt0=Pa*Math.pow(1+0.5*(gamma-1)*M0*M0, gamma/(gamma-1));
  const Tt0=T0*(1+0.5*(gamma-1)*M0*M0);

  const totalL=stages.reduce((s,x)=>s+x.L,0);
  const xSpans=[]; let acc=xLeft;
  stages.forEach(st=>{ const len=(xRight-xLeft)*(st.L/totalL); xSpans.push({x0:acc, x1:acc+len, st}); acc+=len; });

  const Aends=[]; let A_in=A0;
  for(const seg of xSpans){
    const {st}=seg;
    if(st.type!=='nozzle'){
      const A_out=A_in*Math.max(0.05, st.Aout);
      Aends.push({ seg, Ain:A_in, Aout:A_out }); A_in=A_out;
    } else {
      const At=Math.max(0.01, A_in*Math.max(0.02, st.throat));
      const Ae=Math.max(0.01, A_in*Math.max(0.02, st.exit));
      Aends.push({ seg, Ain:A_in, Ath:At, Aout:Ae }); A_in=Ae;
    }
  }

  let Pt=Pt0, Tt=Tt0; const compWork=[];
  for(const info of Aends){
    const st=info.seg.st;
    if(st.type==='compressor'){
      const Tt2s=Tt*Math.pow(st.PR,(gamma-1)/gamma);
      const Tt2 =Tt + (Tt2s-Tt)/Math.max(0.01, st.eta);
      Pt*=st.PR; compWork.push(Tt2-Tt); Tt=Tt2;
    } else if(st.type==='combustor'){
      Pt*=(1 - Math.max(0, Math.min(0.3, st.dPpct/100)));
      Tt=Math.max(Tt+10, st.TtOut);
    }
  }

  const compSum_dT=compWork.reduce((s,x)=>s+x,0);
  const turbStages=Aends.filter(x=>x.seg.st.type==='turbine');

  if(turbStages.length>0){
    Pt=Pt0; Tt=Tt0;
    for(const info of Aends){
      const st=info.seg.st;
      info.Tt_in=Tt; info.Pt_in=Pt;
      if(st.type==='compressor'){
        const Tt2s=Tt*Math.pow(st.PR,(gamma-1)/gamma);
        const Tt2 =Tt + (Tt2s-Tt)/Math.max(0.01, st.eta);
        Pt*=st.PR; Tt=Tt2;
      } else if(st.type==='combustor'){
        Pt*=(1 - Math.max(0, Math.min(0.3, st.dPpct/100)));
        Tt=Math.max(Tt+10, st.TtOut);
      } else if(st.type==='turbine'){
        const dT=(compSum_dT/etaMech)/Math.max(1, turbStages.length)/Math.max(0.01, st.eta);
        const Tt_out=Math.max(500, Tt - dT);
        const Tt_out_s=Tt - (Tt - Tt_out)*Math.max(0.01, st.eta);
        const PR_t=Math.pow(Tt/Tt_out_s, gamma/(gamma-1));
        Pt=Math.max(5000, Pt/PR_t);
        Tt=Tt_out;
      }
      info.Tt_out=Tt; info.Pt_out=Pt;
    }
  } else {
    Pt=Pt0; Tt=Tt0;
    for(const info of Aends){
      info.Tt_in=Tt; info.Pt_in=Pt;
      const st=info.seg.st;
      if(st.type==='compressor'){
        const Tt2s=Tt*Math.pow(st.PR,(gamma-1)/gamma);
        const Tt2 =Tt + (Tt2s-Tt)/Math.max(0.01, st.eta);
        Pt*=st.PR; Tt=Tt2;
      } else if(st.type==='combustor'){
        Pt*=(1 - Math.max(0, Math.min(0.3, st.dPpct/100)));
        Tt=Math.max(Tt+10, st.TtOut);
      }
      info.Tt_out=Tt; info.Pt_out=Pt;
    }
  }

  const N=420; const xs=new Array(N), A=new Array(N), TtArr=new Array(N), PtArr=new Array(N);
  for(let i=0;i<N;i++){
    const xf=i/(N-1); const x=xLeft + xf*(xRight-xLeft); xs[i]=x;
    let segInfo=null; for(const info of Aends){ if(x>=info.seg.x0 && x<=info.seg.x1){ segInfo=info; break; } }
    if(!segInfo){ A[i]=A0; TtArr[i]=Tt0; PtArr[i]=Pt0; continue; }
    const {x0,x1,st}=segInfo.seg; const u=(x-x0)/Math.max(1e-9,(x1-x0)); const s=smooth(Math.max(0,Math.min(1,u)));
    if(st.type!=='nozzle'){ const Ain=segInfo.Ain, Aout=segInfo.Aout; A[i]=Ain*(1-s)+Aout*s; }
    else { const Ain=segInfo.Ain, Ath=segInfo.Ath, Aout=segInfo.Aout; const mid=0.5;
           if(u<=mid){ const t=smooth(u/mid); A[i]=Ain*(1-t)+Ath*t; }
           else       { const t=smooth((u-mid)/(1-mid)); A[i]=Ath*(1-t)+Aout*t; } }
    const Tin=segInfo.Tt_in??Tt0, Pin=segInfo.Pt_in??Pt0, Tout=segInfo.Tt_out??Tin, Pout=segInfo.Pt_out??Pin;
    TtArr[i]=Tin*(1-s)+Tout*s; PtArr[i]=Pin*(1-s)+Pout*s;
  }

  const rho_inf = Pa/(R*Ta); const V0inf = V0; const m_supply = rho_inf*V0inf*Math.max(1e-6,A0);
  let m_choke=Infinity; for(let i=0;i<N;i++){ const cap=critMassFlux(PtArr[i], TtArr[i]) * Math.max(1e-6,A[i]); if(cap<m_choke) m_choke=cap; }
  const mdot=Math.max(1e-5, Math.min(m_supply, m_choke));

  const M=new Array(N), V=new Array(N), T=new Array(N), P=new Array(N), rho=new Array(N), choked=new Array(N);
  for(let i=0;i<N;i++){
    const G=mdot/Math.max(1e-9,A[i]); const Mx=solveM_subsonic(G, PtArr[i], TtArr[i]); M[i]=Mx;
    T[i]=T_static(TtArr[i],Mx); P[i]=P_static(PtArr[i],Mx); V[i]=Mx*aFromT(T[i]); rho[i]=P[i]/(R*T[i]); choked[i]=(Mx>=0.999);
  }

  return { xs, A, Tt:TtArr, Pt:PtArr, M, V, T, P, rho, mdot, chokeAny: choked.some(x=>x) };
}

/* =========================  Streamlines / Drawing  ========================= */
let flow = buildField();

function buildStreamlines(){
  const nLines=Math.max(4, Math.min(60, +el('nLines').value|0));
  const nPackets=Math.max(20, Math.min(200, +el('nPackets').value|0));
  const lines=[];
  for(let j=0;j<nLines;j++){
    const frac=(j+1)/(nLines+1);
    const packets=[];
    // random seed each build to make the dots "different"
    for(let k=0;k<nPackets;k++){
      // randomize starting u slightly so dots don't lock to fixed grid
      const jitter = (Math.random()-0.5) * (1/nPackets);
      const u = (k/nPackets + jitter + 1) % 1;
      packets.push({ u, age: Math.random()*10 });
    }
    lines.push({ f: frac, pk: packets });
  }
  return lines;
}
let stream = buildStreamlines();

function halfHeightAt(x){
  const Hscale=Math.max(0.05, Math.min(0.9, +el('Hscale').value));
  const xs=flow.xs, A=flow.A; const N=xs.length;
  let i=Math.floor( (x - xLeft)/(xRight-xLeft) * (N-1) );
  i=Math.max(0, Math.min(N-2, i));
  const t=(x - xs[i]) / Math.max(1e-9, (xs[i+1]-xs[i]));
  const Aval=A[i]*(1-t) + A[i+1]*t;
  const base=(Hscale*H)*0.5;
  return base * Math.sqrt(Math.max(0.02, Aval/Math.max(0.02, +el('A0').value)));
}
function topY(x){ return H*0.5 - halfHeightAt(x); }
function botY(x){ return H*0.5 + halfHeightAt(x); }
function localInterp(arr,x){
  const xs=flow.xs; const N=xs.length;
  if(x<=xs[0]) return arr[0];
  if(x>=xs[N-1]) return arr[N-1];
  const idx=Math.max(0, Math.min(N-2, Math.floor( (x - xs[0])/(xs[N-1]-xs[0]) * (N-1) )));
  const x1=xs[idx], x2=xs[idx+1]; const u=(x-x1)/Math.max(1e-9,(x2-x1));
  return arr[idx]*(1-u)+arr[idx+1]*u;
}

function drawDuct(){
  ctx.save();
  ctx.strokeStyle='#fff'; ctx.lineWidth=2;
  ctx.beginPath();
  const N=320;
  for(let i=0;i<=N;i++){
    const u=i/N; const x=xLeft + u*(xRight-xLeft); const y=topY(x);
    if(i===0) ctx.moveTo(x*W,y); else ctx.lineTo(x*W,y);
  }
  for(let i=N;i>=0;i--){
    const u=i/N; const x=xLeft + u*(xRight-xLeft); const y=botY(x);
    ctx.lineTo(x*W,y);
  }
  ctx.closePath();
  ctx.stroke();

  // === Stage divider lines (animated dashes) ===
  ctx.setLineDash([6,6]);
  ctx.lineDashOffset = -dashPhase;   // animates to show "time"
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#aaa';
  for(const info of stagesXSpans){
    const X = info.x0 * W;
    ctx.beginPath();
    ctx.moveTo(X, topY(info.x0)-18);
    ctx.lineTo(X, botY(info.x0)+18);
    ctx.stroke();
  }
  ctx.setLineDash([]);
  ctx.restore();
}

/* ===== Temperature gradient (underlay) ===== */
function colorFromT(T,Tmin,Tmax){
  const t=Math.max(0, Math.min(1, (T-Tmin)/Math.max(1e-6,(Tmax-Tmin))));
  if(t<0.5){ const k=t/0.5;
    const r=0, g=Math.round(50+130*k), b=Math.round(220-130*k);
    return `rgb(${r},${g},${b})`;
  } else { const k=(t-0.5)/0.5;
    const r=Math.round(57*(1-k)+255*k);
    const g=Math.round(208*(1-k)+86*k);
    const b=Math.round(102*(1-k)+7*k);
    return `rgb(${r},${g},${b})`;
  }
}
function drawTemperature(){
  const left=xLeft*W, top=topY(xLeft), bottom=botY(xLeft);
  const innerH=bottom-top;
  const Tmin = Math.min(...flow.T), Tmax = Math.max(...flow.T);
  ctx.save(); ctx.globalAlpha=0.78;
  for(let i=0;i<flow.xs.length-1;i++){
    const x0=flow.xs[i]*W, x1=flow.xs[i+1]*W;
    const c0=colorFromT(flow.T[i], Tmin, Tmax);
    const c1=colorFromT(flow.T[i+1], Tmin, Tmax);
    const grd=ctx.createLinearGradient(x0,top,x1,top);
    grd.addColorStop(0,c0); grd.addColorStop(1,c1);
    ctx.fillStyle=grd; ctx.fillRect(x0, top, Math.max(1, x1-x0), innerH);
  }
  ctx.restore();
}

/* ===== Streamlines: compress/expand with rhoV; “dotted feel” via reseed ===== */
function drawStreamlines(dt){
  const pxSpeedScale=0.5; // px per (m/s) per ms
  const trail=Math.max(5, Math.min(60, +el('trail').value|0));
  ctx.save(); ctx.lineCap='round';
  const rhoV0 = (flow.rho[0]*flow.V[0]);

  for(const L of stream){
    ctx.strokeStyle='rgba(255,255,255,0.80)';
    ctx.lineWidth=1.6;

    for(const p of L.pk){
      let x = xLeft + p.u*(xRight-xLeft);
      const Vx = localInterp(flow.V, x);
      const dx = Vx * pxSpeedScale * dt / W;
      p.u += dx / (xRight - xLeft);
      if(p.u > 1.02) p.u -= 1.02;

      ctx.beginPath();
      for(let s=0;s<=trail;s++){
        let u = p.u - s*0.0025;
        if(u<0) u += 1.02;
        const xN = xLeft + (u)*(xRight-xLeft);
        const rhoV = Math.max(1e-6, localInterp(flow.rho, xN)*localInterp(flow.V, xN));
        const S = Math.max(0.35, Math.min(1.8, rhoV0 / rhoV)); // vertical squeeze
        const fS = 0.5 + (L.f - 0.5)*S;
        const yTop = topY(xN), yBot = botY(xN);
        const y = yTop*(1-fS) + yBot*(fS);
        const X = xN*W, Y = y;
        if(s===0) ctx.moveTo(X,Y); else ctx.lineTo(X,Y);
      }
      ctx.stroke();
    }
  }
  ctx.restore();
}

function drawHUD(){
  ctx.save(); ctx.fillStyle='#fff'; ctx.font='12px system-ui, sans-serif';
  const lines=[ `ṁ = ${flow.mdot.toFixed(2)} kg/s`, `choking: ${flow.chokeAny ? 'active' : 'inactive'}` ];
  let y=H-14*lines.length-12, x=14; for(const L of lines){ ctx.fillText(L,x,y); y+=14; }
  ctx.restore();
}

/* =========================  Thrust (momentum + pressure)  ========================= */
function isaAt(alt_m){
  // Simple ISA troposphere
  const lapse=-0.0065, T0=288.15, P0=101325;
  const T=Math.max(180, T0 + lapse*alt_m);
  const P=P0*Math.pow(T/T0, -9.80665/(R*lapse));
  return {T,P};
}
function computeFinalThrust(){
  const alt = +el('alt_m').value||0;
  const V0_user = +el('V0_ms').value||0;
  const Ta = +el('Ta').value;
  const Pa_input = (+el('Pa').value)*1000;

  const a0 = aFromT(Ta);
  const V0_calc = (+el('M0').value)*a0;
  const V0 = (V0_user>0? V0_user : V0_calc);

  const Pamb = alt>0 ? isaAt(alt).P : Pa_input;

  const N=flow.xs.length-1;
  const Vex=flow.V[N], Pex=flow.P[N], Aex=Math.max(1e-6, flow.A[N]), mdot=flow.mdot;

  const F = mdot*(Vex - V0) + (Pex - Pamb)*Aex; // Newtons
  el('thrustN').textContent = Number.isFinite(F)? F.toFixed(2): '0';
}

/* =========================  Orchestration  ========================= */
function rebuildField(){
  flow = buildField();

  // spans for stage boundary markers
  const totalL=stages.reduce((s,x)=>s+x.L,0);
  let acc=xLeft;
  stagesXSpans = stages.map(st=>{
    const len=(xRight-xLeft)*(st.L/totalL);
    const obj={x0:acc, x1:acc+len, st}; acc+=len; return obj;
  });

  // rebuild streamlines if counts changed
  stream = buildStreamlines();
}

let lastT=performance.now();
function frame(now){
  const dt = Math.min(40, now - lastT) * timeScale;
  lastT = now;

  dashPhase += dt * 0.15;         // animate dashed stage lines
  rebuildField();

  ctx.clearRect(0,0,W,H);
  drawTemperature();
  drawDuct();
  drawStreamlines(dt);
  drawHUD();

  requestAnimationFrame(frame);
}

/ initial build so spans exist before first draw //
rebuildField();
requestAnimationFrame(frame);

/* ===== Interactions for cues ===== */
function reseedVelocityCues(){
  dashPhase = Math.random()*1000; // randomize dash “phase”
  stream = buildStreamlines();    // reseed streamline dots
}
el('M0').addEventListener('input', reseedVelocityCues);
el('V0_ms').addEventListener('input', reseedVelocityCues);

/* ===== Slow-mo buttons ===== */
const timeOut = el('timeScaleOut');
el('btnSlow').addEventListener('click', ()=>{ timeScale = 0.25; timeOut.textContent = '0.25×'; });
el('btnNormal').addEventListener('click', ()=>{ timeScale = 1.00; timeOut.textContent = '1.00×'; });

/* ===== Thrust button ===== */
el('btnThrust').addEventListener('click', computeFinalThrust);
if (stages.length === 0) resetDefault();
rebuildField();
requestAnimationFrame(frame);
requestAnimationFrame(frame);

// UI: thrust button
el('btnThrust').addEventListener('click', computeFinalThrust);

// === Tooltip Fix for Mobile ===
document.querySelectorAll('.tooltip[title]').forEach(tip=>{
  const text = tip.getAttribute('title');
  tip.removeAttribute('title');
  const box = document.createElement('span');
  box.className = 'tooltip-box';
  box.textContent = text;
  tip.appendChild(box);

  tip.addEventListener('click', ()=>{
    tip.classList.toggle('active');
  });
});

</script>
</body>
</html>


